

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Legend &mdash; Hyperledger Indy SDK  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          


          
            <a href="../../rtd-index.html" class="icon icon-home"> Hyperledger Indy SDK
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          

<br><img style="background-color: #fff; height: unset; width: unset;" alt="Hyperledger Indy" src="_static/images/indy-logo.png" />
<br>
<a href="https://github.com/hyperledger/indy-sdk.git"><img style="padding: 0px; margin: auto auto auto auto;" alt="GitHub" src="_static/images/github_button.png"/></a>
&nbsp;<a href="https://stackoverflow.com/questions/tagged/hyperledger-fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="StackOverflow" src="_static/images/stackoverflow_button.png"/></a>
&nbsp;<a href="https://chat.hyperledger.org"><img style="padding: 0px; margin: auto auto auto auto;" alt="Rocket Chat" src="_static/images/rocketchat_button.png"/></a>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started/getting-started.html">Getting Started with Libindy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rtd-tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rtd-design.html">Indy SDK Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rtd-building.html">Building Indy SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rtd-migration-guides.html">Libindy Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-workflow.html">Release process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../signing-commits.html">Signing commits</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../rtd-index.html">Hyperledger Indy SDK</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../rtd-index.html">Docs</a> &raquo;</li>
        
      <li>Legend</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/design/008-state-proof-pluggable-parsing/README.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="legend">
<span id="legend"></span><h1>Legend<a class="headerlink" href="#legend" title="Permalink to this headline">¶</a></h1>
<p>There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.</p>
<p>BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes.</p>
</div>
<div class="section" id="goals">
<span id="goals"></span><h1>Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h1>
<p>Libindy allows to extend building of supported requests via plugged interface and send them.
It is nice to have a way to support BLS MS and SP verification for these plugged transactions.</p>
<p>Implementation of math for SP verification is a bit complicate for plugin logic.
Therefore libindy should perform all math calculation inside.
A plugin should provide handler to parse custom reply to fixed data structure.</p>
</div>
<div class="section" id="api">
<span id="api"></span><h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<p>The signature of the handler is described below together with custom <code class="docutils literal notranslate"><span class="pre">free</span></code> call to deallocate result data.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="k">fn</span> <span class="nf">CustomTransactionParser</span><span class="p">(</span><span class="n">reply_from_node</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">c_char</span><span class="p">,</span><span class="w"> </span><span class="n">parsed_sp</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">c_char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ErrorCode</span><span class="p">;</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="k">fn</span> <span class="nf">CustomFree</span><span class="p">(</span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">c_char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ErrorCode</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Libindy API will contain call to register handler for specific transaction type:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="k">fn</span> <span class="nf">indy_register_transaction_parser_for_sp</span><span class="p">(</span><span class="n">command_handle</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                  </span><span class="n">txn_type</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">c_char</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                  </span><span class="n">parser</span>: <span class="nc">CustomTransactionParser</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                  </span><span class="n">free</span>: <span class="nc">CustomFree</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                  </span><span class="n">cb</span>: <span class="nc">extern</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="n">command_handle_</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">err</span>: <span class="nc">ErrorCode</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">ErrorCode</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="parsed-data-structure">
<span id="parsed-data-structure"></span><h2>Parsed Data structure<a class="headerlink" href="#parsed-data-structure" title="Permalink to this headline">¶</a></h2>
<p>A plugin should parse <code class="docutils literal notranslate"><span class="pre">reply_from_node</span></code> and return back to libindy parsed data as JSON string.
Actually this data is array of entities each of them is describe SP Trie and set of key-value pairs to verify against this trie.
It can be represented as <code class="docutils literal notranslate"><span class="pre">Vec&lt;ParsedSP&gt;</span></code> serialized to JSON.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">/**</span>
<span class="sd"> Single item to verification:</span>
<span class="sd"> - SP Trie with RootHash</span>
<span class="sd"> - BLS MS</span>
<span class="sd"> - set of key-value to verify</span>
<span class="sd">*/</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">ParsedSP</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// encoded SP Trie transferred from Node to Client</span>
<span class="w">    </span><span class="n">proof_nodes</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// RootHash of the Trie, start point for verification. Should be same with appropriate filed in BLS MS data</span>
<span class="w">    </span><span class="n">root_hash</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// entities to verification against current SP Trie</span>
<span class="w">    </span><span class="n">kvs_to_verify</span>: <span class="nc">KeyValuesInSP</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// BLS MS data for verification</span>
<span class="w">    </span><span class="n">multi_signature</span>: <span class="nc">serde_json</span>::<span class="n">Value</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="sd">/**</span>
<span class="sd"> Variants of representation for items to verify against SP Trie</span>
<span class="sd"> Right now 2 options are specified:</span>
<span class="sd"> - simple array of key-value pair</span>
<span class="sd"> - whole subtrie</span>
<span class="sd">*/</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">KeyValuesInSP</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Simple</span><span class="p">(</span><span class="n">KeyValueSimpleData</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">SubTrie</span><span class="p">(</span><span class="n">KeyValuesSubTrieData</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="sd">/**</span>
<span class="sd"> Simple variant of `KeyValuesInSP`.</span>

<span class="sd"> All required data already present in parent SP Trie (built from `proof_nodes`).</span>
<span class="sd"> `kvs` can be verified directly in parent trie</span>
<span class="sd">*/</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">KeyValueSimpleData</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">kvs</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="w"> </span><span class="cm">/* b64-encoded key */</span><span class="p">,</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="w"> </span><span class="cm">/* val */</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="sd">/**</span>
<span class="sd"> Subtrie variant of `KeyValuesInSP`.</span>

<span class="sd"> In this case Client (libindy) should construct subtrie and append it into trie based on `proof_nodes`.</span>
<span class="sd"> After this preparation each kv pair can be checked.</span>
<span class="sd">*/</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">KeyValuesSubTrieData</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// base64-encoded common prefix of each pair in `kvs`. Should be used to correct merging initial trie and subtrie</span>
<span class="w">    </span><span class="n">sub_trie_prefix</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">kvs</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="w"> </span><span class="cm">/* b64-encoded key_suffix */</span><span class="p">,</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="w"> </span><span class="cm">/* val */</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Expected libindy and plugin workflow is the following:</p>
<ol class="simple">
<li>Libindy receive reply from a Node, perform initial processing and pass raw reply to plugin.</li>
<li>Plugin parse reply from the Node and specify one or more SP Trie with metadata and items for verification.</li>
<li>Each SP Trie described by plugin as <code class="docutils literal notranslate"><span class="pre">ParsedSP</span></code>:<ol>
<li>Set of encoded nodes of the SP Trie, received from Node - <code class="docutils literal notranslate"><span class="pre">proof_nodes</span></code>. May be fetched from response “as is”.</li>
<li>RootHash of this Trie. May be fetched from the response “as is” also.</li>
<li>BLS MS data. Again may be fetched from the response “as is”.</li>
<li>Key-value items to verification. Here plugin should define correct keys (path in the trie) and corresponded values.</li>
</ol>
</li>
<li>Plugin return serialized as JSON array of <code class="docutils literal notranslate"><span class="pre">ParsedSP</span></code></li>
<li>For each <code class="docutils literal notranslate"><span class="pre">ParsedSP</span></code> libindy:<ol>
<li>build base trie from <code class="docutils literal notranslate"><span class="pre">proof_nodes</span></code></li>
<li>if items to verify is <code class="docutils literal notranslate"><span class="pre">SubTrie</span></code>, construct this subtrie from (key-suffix, value) pairs and merge it with trie from clause above</li>
<li>iterate other key-value pairs and verify that trie (with signed <code class="docutils literal notranslate"><span class="pre">root_hash</span></code>) contains <code class="docutils literal notranslate"><span class="pre">value</span></code> at specified <code class="docutils literal notranslate"><span class="pre">key</span></code></li>
<li>verify multi-signature</li>
</ol>
</li>
<li>If any verification is failed, libindy ignore particular SP + BLS MS and try to request same data from another node,
or collect consensus of same replies from enough count of Nodes.</li>
</ol>
<p>Below is JSON structure for <code class="docutils literal notranslate"><span class="pre">Simple</span></code> case.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
 <span class="p">{</span>
   <span class="nt">&quot;proof_nodes&quot;</span><span class="p">:</span> <span class="s2">&quot;string with serialized SP tree&quot;</span><span class="p">,</span>
   <span class="nt">&quot;root_hash&quot;</span><span class="p">:</span> <span class="s2">&quot;string with root hash&quot;</span><span class="p">,</span>
   <span class="nt">&quot;kvs_to_verify&quot;</span><span class="p">:</span> <span class="p">{</span>
     <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;simple&quot;</span><span class="p">,</span>
     <span class="nt">&quot;kvs&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;key1&quot;</span><span class="p">,</span> <span class="s2">&quot;value1&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;key2&quot;</span><span class="p">,</span> <span class="s2">&quot;value2&quot;</span><span class="p">]]</span>
   <span class="p">},</span>
   <span class="nt">&quot;multi_signature&quot;</span><span class="p">:</span> <span class="s2">&quot;JSON object from Node`s reply as is&quot;</span>
 <span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="simple-and-subtrie-verification">
<span id="simple-and-subtrie-verification"></span><h2>Simple and SubTrie verification<a class="headerlink" href="#simple-and-subtrie-verification" title="Permalink to this headline">¶</a></h2>
<p>Some use cases require verification multiply pairs of key-value in one Trie.
Moreover there is possible situation when client would like to verify whole subtrie.
In this case, the amount of data transferred from Node to Client can be significantly reduced.
Instead of including all nodes for SP verification to <code class="docutils literal notranslate"><span class="pre">proof_nodes</span></code>, Node can include only prefix path down to subtrie.
The entire subtrie to verification can be restored on Client side from key-value pairs and combined with prefix part.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Hyperledger

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>