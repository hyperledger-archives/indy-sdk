#!groovy

@Library('SovrinHelpers') _

testReleaseVersion = env.INDY_SDK_TEST_RELEASE_VERSION ?: null

properties([
        [$class: 'BuildDiscarderProperty', strategy: [
                $class               : 'LogRotator',
                artifactDaysToKeepStr: '28',
                artifactNumToKeepStr : '',
                daysToKeepStr        : '28',
                numToKeepStr         : ''
        ]]
]);

libindyBuildFinished = ["Ubuntu": false, "RedHat": false]
libvcxBuildFinished = ["Ubuntu": false, "RedHat": false]

gitHubUserCredId = env.GITHUB_BOT_USER ?: 'sovbot-github'
sovrinPackagingRepo = env.SOVRIN_PACKAGING_REPO ?: 'https://github.com/sovrin-foundation/sovrin-packaging'
sovrinPackagingBranch = env.SOVRIN_PACKAGING_BRANCH ?: 'master'
mavenDeployAddOptions = env.MAVEN_DEPLOY_ADD_OPTIONS ?: ''

try {
    testing()
    publishing()
    if (acceptanceTesting()) {
        releasing()
    }
    notifyingSuccess()
} catch (err) {
    notifyingFailure()
    throw err
}

def testing() {
    stage('Static Analysis') {
        staticValidation()
    }
    stage('Testing') {
        parallel([
                'ubuntu-test' : { ubuntuTesting() },
                //  FIXME 'redhat-test' : { rhelTesting() }, https://jira.hyperledger.org/browse/IS-1212
                'android-test': { androidTesting() },
                'windows-test': { windowsTesting() },
                'ios-test'    : { iosTesting() },
                'macos-test'  : { macosTesting() }
        ])
    }
}

def publishing() {
    stage('Publishing') {
        echo "${env.BRANCH_NAME}: start publishing"
        publishedVersions = parallel([
                //FIXME fix and restore 'rhel-files'     : { rhelPublishing() }, IS-307
                'ubuntu-files' : { ubuntuPublishing() },
                'windows-files': { windowsPublishing() },
                'android-files': { androidPublishing() },
                'ios-files'    : { iosPublishing() },
                'macos-files': { macOsPublishing() },
        ])

        if (publishedVersions['windows-files'] != publishedVersions['ubuntu-files']) { // FIXME check rhel too, IS-307
            error "platforms artifacts have different versions"
        }
    }
}

def acceptanceTesting() {
    stage('Acceptance testing') {
        if (env.BRANCH_NAME == 'rc') {
            echo "${env.BRANCH_NAME}: acceptance testing"
            if (approval.check("default")) {
                return true
            }
        } else {
            echo "${env.BRANCH_NAME}: skip acceptance testing"
        }
        return false
    }
}

def releasing() {
    stage('Releasing') {
        if (env.BRANCH_NAME == 'rc') {
            publishingRCtoStable()
        }
    }
}

def notifyingSuccess() {
    currentBuild.result = "SUCCESS"
    node('ubuntu-master') {
        sendNotification.success('indy-sdk')
    }
}

def notifyingFailure() {
    currentBuild.result = "FAILED"
    node('ubuntu-master') {
        sendNotification.fail([slack: true])
    }
}

def staticValidation() {
    parallel([
            'libindy'   : { runValdiationRust('libindy') },
            'libnullpay': { runValdiationRust('libnullpay') },
            'libvcx'    : { runValdiationRust('vcx/libvcx') },
            'cli'       : { runValdiationRust('cli') }
    ])
}

def runValdiationRust(dir) {
    node('ubuntu') {
        checkout scm
        if (dir == 'vcx/libvcx') {
            testEnv = dockerBuild("static-validation-libvcx", "vcx/ci/ubuntu.dockerfile .")
        } else {
            testEnv = dockerBuild("static-validation-libindy", "libindy/ci/ubuntu.dockerfile libindy/ci")
        }
        testEnv.inside {
            //FIXME waiting on IS-823
            //sh "cargo clippy --manifest-path ${dir}/Cargo.toml"
            sh "cargo clippy --manifest-path ${dir}/Cargo.toml -- -W clippy::style -W clippy::correctness -W clippy::complexity -W clippy::perf"
        }
    }
}

def getBuildPoolVerOptions(pool_type, plenum_ver, anoncreds_ver, node_ver) {
    if (pool_type != null && plenum_ver != null && anoncreds_ver != null && node_ver != null) {
        return "--build-arg=indy_stream=${pool_type} --build-arg indy_plenum_ver=${plenum_ver} --build-arg indy_anoncreds_ver=${anoncreds_ver} --build-arg indy_node_ver=${node_ver}"
    } else {
        return ""
    }
}

def getUserUid() {
    return sh(returnStdout: true, script: 'id -u').trim()
}

def dockerBuild(name, file = 'ci/ubuntu.dockerfile ci', customParams = '') {
    return docker.build("$name-test", "--build-arg uid=${getUserUid()} ${customParams} -f $file")
}

def dockerClean(env_name, network_name) {
    try {
        try {
            sh "docker ps --format '{{.ID}}' --filter network=${network_name} | xargs docker rm -f || true"
            //TODO: FIXME
        } catch (error) {
            echo "${env_name} Test: error while force clean-up network ${network_name} - ${error}"
        }
        try {
            echo "${env_name} Test: remove pool network ${network_name}"
            sh "docker network rm ${network_name} || true" //TODO: FIXME
        } catch (error) {
            echo "${env_name} Test: error while delete ${network_name} - ${error}"
        }
    }
    finally {
        sh "docker container prune -f"
        sh "docker network prune -f"
    }
}

def openPool(env_name, network_name, pool_type = null, pool_ver = null, plenum_ver = null, anoncreds_ver = null, node_ver = null) {
    echo "${env_name} Test: Clean docker"
    dockerClean(env_name, network_name)

    echo "${env_name} Test: Create docker network (${network_name}) for nodes pool and test image"
    sh "docker network create --subnet=10.0.0.0/8 ${network_name}"

    echo "${env_name} Test: Build docker image for nodes pool ver. ${pool_ver}"
    echo "${env_name} Test: Building nodes pool for versions: plenum ${plenum_ver}, anoncreds ${anoncreds_ver}, node ${node_ver}"
    verOptions = getBuildPoolVerOptions(pool_type, plenum_ver, anoncreds_ver, node_ver)
    def poolEnv = dockerHelpers.build("indy_pool_${pool_ver}", 'ci/indy-pool.dockerfile ci',
            "--build-arg pool_ip=10.0.0.2 ${verOptions}")
    echo "${env_name} Test: Run nodes pool"
    return poolEnv.run("--ip=\"10.0.0.2\" --network=${network_name}")
}

def closePool(env_name, network_name, poolInst) {
    echo "${env_name} Test: Cleanup"
    try {
        echo "${env_name} Test: stop pool"
        poolInst.stop()
    } catch (error) {
        echo "${env_name} Tests: error while stop pool ${error}"
    }
    finally {
        dockerClean(env_name, network_name)
    }
    step([$class: 'WsCleanup'])
}


String getSrcVersion(folder) {
    if (testReleaseVersion) {
        return testReleaseVersion
    } else {
        commit = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
        def version = sh(returnStdout: true, script: "wget -q https://raw.githubusercontent.com/hyperledger/indy-sdk/$commit/$folder/Cargo.toml -O - | grep -E '^version =' | head -n1 | cut -f2 -d= | cut -f2 -d '\"'").trim()
        return version
    }
}

def linuxTesting(file, env_name, network_name, stashBuildResults) {
    parallel([
            failFast                                  : true,
            "${env_name} Test: build and test libindy": {
                node('ubuntu') {
                    linuxLibindyBuild(file, env_name, network_name, stashBuildResults)
                }
            },
            "${env_name} Test: test other components" : {
                waitUntil {
                    libindyBuildFinished[env_name]
                }
                def jobs = [
                        "${env_name}-cli-test"   : {
                            linuxModuleTesting(file, env_name, network_name, this.&linuxCLITesting, stashBuildResults)
                        },
                        "${env_name}-rust-test"  : {
                            linuxModuleTesting(file, env_name, network_name, this.&linuxRustTesting, stashBuildResults)
                        },
                        "${env_name}-nodejs-test": {
                            linuxModuleTesting(file, env_name, network_name, this.&linuxNodejsTesting, stashBuildResults)
                        },
                        "${env_name}-vcx-test"   : {
                            vcxTesting(file, env_name, network_name, stashBuildResults)
                        }
                ]
                if (env_name == "Ubuntu") {
                    jobs["${env_name}-java-test"] = {
                        linuxModuleTesting(file, env_name, network_name, this.&linuxJavaTesting, stashBuildResults)
                    }
                    jobs["${env_name}-python-test"] = {
                        linuxModuleTesting(file, env_name, network_name, this.&linuxPythonTesting, stashBuildResults)
                    }
                }
                parallel(jobs)
            },
    ])
}

def vcxTesting(file, env_name, network_name, stashBuildResults) {
    parallel([
            failFast                                     : true,
            "${env_name} Test: build and test libvcx"    : {
                node('ubuntu') {
                    linuxVcxBuild(file, env_name, network_name, stashBuildResults)
                }
            },
            "${env_name} Test: test other vcx components": {
                waitUntil {
                    libvcxBuildFinished[env_name]
                }
                def jobs = [
                        "${env_name}-vcx-nodejs-test": {
                            linuxModuleTesting(file, env_name, network_name, this.&linuxVcxNodejsTesting, stashBuildResults)
                        }
                ]
                if (env_name == "Ubuntu") {
                    jobs["${env_name}-vcx-java-test"] = {
                        linuxModuleTesting(file, env_name, network_name, this.&linuxVcxJavaTesting, stashBuildResults)
                    }
                    jobs["${env_name}-vcx-python-test"] = {
                        linuxModuleTesting(file, env_name, network_name, this.&linuxVcxPythonTesting, stashBuildResults)
                    }
                }
                parallel(jobs)
            },
    ])
}

def linuxLibindyBuild(file, env_name, network_name, stashBuildResults) {
    def poolInst
    try {
        echo "${env_name} Test: Checkout csm"
        checkout scm

        poolInst = openPool(env_name, network_name)

        def testEnv = buildTestEnv(file, env_name)

        testEnv.inside {
            echo "${env_name} Libindy Test: Build"
            sh '''
                cd libindy
                cargo build --release --features "fatal_warnings sodium_static"
            '''

            if (stashBuildResults) {
                stash includes: 'libindy/target/release/libindy.so,libindy/target/release/libindy.a', name: 'LibindyUbuntuBuildResult'
            }
        }

        sh "cp libindy/target/release/libindy.so wrappers/java/lib"
        sh "cp libindy/target/release/libindy.so wrappers/python"
        sh "cp libindy/target/release/libindy.so wrappers/rust"
        sh "cp libindy/target/release/libindy.so wrappers/nodejs"
        sh "cp libindy/target/release/libindy.so cli"
        sh "cp libindy/target/release/libindy.so libnullpay"
        sh "cp libindy/target/release/libindy.so vcx/libvcx"
        sh "cp libindy/target/release/libindy.so vcx/wrappers/node"
        sh "cp libindy/target/release/libindy.so vcx/wrappers/java"
        sh "cp libindy/target/release/libindy.so vcx/wrappers/python3"
        sh "cp libindy/target/release/libindy.so vcx/dummy-cloud-agent"

        testEnv.inside {
            echo "${env_name} Libnullpay Test: Build"
            sh '''
                cd libnullpay
                LIBRARY_PATH=./ RUST_BACKTRACE=1 cargo build --release
            '''

            if (stashBuildResults) {
                stash includes: 'libnullpay/target/release/libnullpay.so', name: 'LibnullpayUbuntuBuildResult'
            }
        }

        sh "cp libnullpay/target/release/libnullpay.so cli"
        sh "cp libnullpay/target/release/libnullpay.so vcx/libvcx"
        sh "cp libnullpay/target/release/libnullpay.so vcx/wrappers/node"
        sh "cp libnullpay/target/release/libnullpay.so vcx/wrappers/java"
        sh "cp libnullpay/target/release/libnullpay.so vcx/wrappers/python3"

        stash includes: 'wrappers/java/lib/libindy.so', name: "LibindyJavaSO${env_name}"
        stash includes: 'wrappers/python/libindy.so', name: "LibindyPythonSO${env_name}"
        stash includes: 'wrappers/rust/libindy.so', name: "LibindyRustSO${env_name}"
        stash includes: 'wrappers/nodejs/libindy.so', name: "LibindyNodejsSO${env_name}"
        stash includes: 'cli/libindy.so', name: "LibindyCliSO${env_name}"
        stash includes: 'cli/libnullpay.so', name: "LibnullpayCliSO${env_name}"
        stash includes: 'vcx/libvcx/libindy.so,vcx/libvcx/libnullpay.so', name: "VCXLibindyAndLibnullpaySO${env_name}"
        stash includes: 'vcx/wrappers/node/libindy.so,vcx/wrappers/node/libnullpay.so', name: "VcxNodeLibindyAndLibnullpaySO${env_name}"
        stash includes: 'vcx/wrappers/java/libindy.so,vcx/wrappers/java/libnullpay.so', name: "VcxJavaLibindyAndLibnullpaySO${env_name}"
        stash includes: 'vcx/wrappers/python3/libindy.so,vcx/wrappers/python3/libnullpay.so', name: "VcxPythonLibindyAndLibnullpaySO${env_name}"
        stash includes: 'vcx/dummy-cloud-agent/libindy.so', name: "LibindyCloudAgentSO${env_name}"

        libindyBuildFinished[env_name] = true

        echo "${env_name} Libindy Test: Test"
        testEnv.inside("--network=${network_name}") {
            sh '''
                cd libindy
                RUST_BACKTRACE=1 cargo test --release --no-run --features sodium_static
                RUST_BACKTRACE=1 RUST_LOG=indy::=debug,zmq=trace RUST_TEST_THREADS=1 TEST_POOL_IP=10.0.0.2 cargo test --release --features sodium_static
            '''
        }

        echo "${env_name} Libnullpay Test: Test"
        testEnv.inside("--network=${network_name}") {
            sh '''
                cd libnullpay
                LIBRARY_PATH=./ RUST_BACKTRACE=1 cargo test --no-run --release
                LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_BACKTRACE=1 RUST_LOG=debug RUST_TEST_THREADS=1 TEST_POOL_IP=10.0.0.2 cargo test --release
            '''
        }

    }
    finally {
        closePool(env_name, network_name, poolInst)
    }
}

def linuxVcxBuild(file, env_name, network_name, stashBuildResults) {
    def poolInst
    try {
        echo "${env_name} Test: Checkout csm"
        checkout scm

        poolInst = openPool(env_name, network_name)

        def testEnv = buildTestEnv(file, env_name)

        unstash name: "VCXLibindyAndLibnullpaySO${env_name}"

        echo "${env_name} Libvcx Test: Build"
        testEnv.inside {
            sh '''
                cd vcx/libvcx
                LIBRARY_PATH=./ cargo build --release --features fatal_warnings
            '''
            if (stashBuildResults) {
                stash includes: 'vcx/libvcx/target/release/libvcx.so', name: 'LibvcxUbuntuBuildResult'
            }
        }

        sh "cp vcx/libvcx/target/release/libvcx.so vcx/wrappers/node"
        sh "cp vcx/libvcx/target/release/libvcx.so vcx/wrappers/java"
        sh "cp vcx/libvcx/target/release/libvcx.so vcx/wrappers/python3"

        stash includes: 'vcx/wrappers/node/libvcx.so', name: "VcxNodeLibvcxSO${env_name}"
        stash includes: 'vcx/wrappers/java/libvcx.so', name: "VcxJavaLibvcxSO${env_name}"
        stash includes: 'vcx/wrappers/python3/libvcx.so', name: "VcxPythonLibvcxSO${env_name}"

        libvcxBuildFinished[env_name] = true

        sh "cp vcx/libvcx/libindy.so vcx/dummy-cloud-agent"

        testEnv.inside("--network=${network_name}") {
            sh '''
                cd vcx/dummy-cloud-agent
                LIBRARY_PATH=./ LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_BACKTRACE=1 RUST_LOG=indy=info cargo run config/sample-config.json &
            '''

            echo "${env_name} Libvcx Test: Run tests"
            sh '''
                cd vcx/libvcx
                LIBRARY_PATH=./ LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_BACKTRACE=1 RUST_LOG=vcx=debug,indy=debug RUST_TEST_THREADS=1 TEST_POOL_IP=10.0.0.2 cargo test --release --features "pool_tests agency"
            '''
        }

        testEnv.inside("--network=${network_name}") {
            sh '''
                cd vcx/dummy-cloud-agent
                sed -i 's/\\("protocol_type": "\\)1.0/\\12.0/' config/sample-config.json
                LIBRARY_PATH=./ LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_BACKTRACE=1 RUST_LOG=indy=info cargo run config/sample-config.json &
            '''

            echo "${env_name} Libvcx Test: Run vcx demo test for protocol version 2.0"
            sh '''
                cd vcx/libvcx
                LIBRARY_PATH=./ LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_BACKTRACE=1 RUST_LOG=vcx=debug,indy=debug RUST_TEST_THREADS=1 TEST_POOL_IP=10.0.0.2 cargo test  --release --features "pool_tests agency_v2" tests::test_real_proof_for_protocol_type_v2 -- --exact
            '''
        }
    }
    finally {
        closePool(env_name, network_name, poolInst)
    }
}

def linuxJavaTesting(env_name, network_name, testEnv, stashBuildResults) {
    unstash name: "LibindyJavaSO${env_name}"
    dir('wrappers/java') {
        testEnv.inside("--ip=\"10.0.0.3\" --network=${network_name}") {
            echo "${env_name} Libindy Test: Test java wrapper"

            sh "RUST_LOG=indy::=debug TEST_POOL_IP=10.0.0.2 mvn clean test"
        }
    }
}

def linuxPythonTesting(env_name, network_name, testEnv, stashBuildResults) {
    unstash name: "LibindyPythonSO${env_name}"
    dir('wrappers/python') {
        testEnv.inside("--ip=\"10.0.0.3\" --network=${network_name}") {
            echo "${env_name} Libindy Test: Test python wrapper"

            sh '''
                    python3.5 -m pip install --user -e .[test]
                    LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_LOG=indy::=debug TEST_POOL_IP=10.0.0.2 python3.5 -m pytest
                '''
        }
    }
}

def linuxCLITesting(env_name, network_name, testEnv, stashBuildResults) {
    unstash name: "LibindyCliSO${env_name}"
    unstash name: "LibnullpayCliSO${env_name}"

    echo "${env_name} Indy Cli Test: tests"
    testEnv.inside("--network=${network_name}") {
        sh '''
            cd cli
            LIBRARY_PATH=./ RUST_BACKTRACE=1 cargo build --release --features fatal_warnings
            LIBRARY_PATH=./ RUST_BACKTRACE=1 cargo test --release --features "nullpay_plugin" --no-run
            LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_BACKTRACE=1 RUST_LOG=indy::=debug RUST_TEST_THREADS=1 TEST_POOL_IP=10.0.0.2 cargo test  --release --features "nullpay_plugin"
        '''
        if (stashBuildResults) {
            stash includes: 'cli/target/release/indy-cli', name: 'IndyCliUbuntuBuildResult'
        }
    }
}

def linuxRustTesting(env_name, network_name, testEnv, stashBuildResults) {
    unstash name: "LibindyRustSO${env_name}"

    dir('wrappers/rust') {
        testEnv.inside("--network=${network_name}") {
            echo "${env_name} Indy Rust wrapper Test: Build"
            sh 'LIBRARY_PATH=./ RUST_BACKTRACE=1 cargo test --release --no-run'

            echo "${env_name} Indy Rust wrapper Test: Run tests"
            sh 'LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_BACKTRACE=1 RUST_LOG=indy::=debug RUST_TEST_THREADS=1 TEST_POOL_IP=10.0.0.2 cargo test --release'
        }
    }
}

def linuxNodejsTesting(env_name, network_name, testEnv, stashBuildResults) {
    unstash name: "LibindyNodejsSO${env_name}"
    testEnv.inside("--network=${network_name}") {
        echo "${env_name} Libindy Test: Test nodejs wrapper"

        sh '''
                cd wrappers/nodejs
                npm run prepare
                npm install
                LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} RUST_LOG=indy::=debug TEST_POOL_IP=10.0.0.2 npm test
            '''
    }
}

def linuxVcxNodejsTesting(env_name, network_name, testEnv, stashBuildResults) {
    unstash name: "VcxNodeLibvcxSO${env_name}"
    unstash name: "VcxNodeLibindyAndLibnullpaySO${env_name}"

    testEnv.inside("--network=${network_name}") {
        echo "${env_name} Vcx Test: Test nodejs wrapper"
        sh '''
            cd vcx/wrappers/node/
            npm i
            npm run compile
            LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} LIBVCX_PATH=./ npm test
        '''
    }
}

def linuxVcxJavaTesting(env_name, network_name, testEnv, stashBuildResults) {
    unstash name: "VcxJavaLibvcxSO${env_name}"
    unstash name: "VcxJavaLibindyAndLibnullpaySO${env_name}"

    dir('vcx/wrappers/java') {
        echo "${env_name} Vcx Test: Test java wrapper"

        testEnv.inside("--network=${network_name}") {
            sh 'LIBRARY_PATH=./ LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH}  ./gradlew --no-daemon test'
        }
    }
}

def linuxVcxPythonTesting(env_name, network_name, testEnv, stashBuildResults) {
    unstash name: "VcxPythonLibvcxSO${env_name}"
    unstash name: "VcxPythonLibindyAndLibnullpaySO${env_name}"

    dir('vcx/wrappers/python3') {
        testEnv.inside {
            echo "${env_name} Vcx Test: Test python wrapper"

            sh '''
                    python3.5 -m pip install --user pytest==3.6.4 pytest-asyncio
                    LD_LIBRARY_PATH=./:${LD_LIBRARY_PATH} python3.5 -m pytest -s
            '''
        }
    }
}

def windowsTesting() {
    node('win2016') {
        stage('Windows Test') {
            def ws_path = "workspace/${env.JOB_NAME}".replace(' ', '_')
            ws(ws_path) {
                try {
                    echo "Windows Test: Checkout scm"
                    checkout scm


                    echo "Windows Test: Run Indy pool"
                    bat "docker -H $INDY_SDK_SERVER_IP build --build-arg pool_ip=$INDY_SDK_SERVER_IP -f ci/indy-pool.dockerfile -t indy_pool ci"
                    bat "docker -H $INDY_SDK_SERVER_IP run -d --network host --name indy_pool -p 9701-9708:9701-9708 indy_pool"

                    setupRust()

                    dir('libindy') {
                        echo "Windows Test: Download prebuilt dependencies"
                        bat 'wget -O prebuilt.zip "https://repo.sovrin.org/windows/libindy/deps/indy-sdk-deps.zip"'
                        bat 'unzip prebuilt.zip -d prebuilt'

                        echo "Windows Libindy Test: Build"
                        withEnv([
                                "INDY_PREBUILT_DEPS_DIR=$WORKSPACE\\libindy\\prebuilt",
                                "INDY_CRYPTO_PREBUILT_DEPS_DIR=$WORKSPACE\\libindy\\prebuilt",
                                "MILAGRO_DIR=$WORKSPACE\\libindy\\prebuilt",
                                "LIBZMQ_PREFIX=$WORKSPACE\\libindy\\prebuilt",
                                "SODIUM_LIB_DIR=$WORKSPACE\\libindy\\prebuilt",
                                "OPENSSL_DIR=$WORKSPACE\\libindy\\prebuilt",
                                "PATH=$WORKSPACE\\libindy\\prebuilt\\lib;$PATH",
                                "RUST_BACKTRACE=1"
                        ]) {
                            bat "cargo build --release --features fatal_warnings"
                            bat "cargo test --release --no-run"

                            echo "Windows Libindy Test: Run tests"
                            withEnv([
                                    "RUST_TEST_THREADS=1",
                                    "RUST_LOG=indy::=debug,zmq=trace",
                                    "TEST_POOL_IP=$INDY_SDK_SERVER_IP"
                            ]) {
                                bat "cargo test --release"
                            }
                        }
                        stash includes: 'target/release/*.dll,target/release/*.dll.lib', name: 'LibindyWindowsBuildResult'
                    }

                    dir('libnullpay') {
                        echo "Windows Libnullpay Test: Build"
                        withEnv([
                                "RUST_BACKTRACE=1"
                        ]) {
                            bat "cargo build --release --features fatal_warnings"
                            bat "cargo test --release --no-run"

                            echo "Windows Libnullpay Test: Run tests"
                            withEnv([
                                    "RUST_TEST_THREADS=1",
                                    "RUST_LOG=indy::=debug,zmq=trace",
                                    "TEST_POOL_IP=$INDY_SDK_SERVER_IP",
                                    "PATH=$WORKSPACE\\libindy\\target\\release;$PATH",
                            ]) {
                                bat "cargo test --release"
                            }
                        }

                        stash includes: 'target/release/*.dll,target/release/*.dll.lib', name: 'LibnullpayWindowsBuildResult'
                    }

                    bat "PowerShell.exe \"Copy-Item $WORKSPACE/libnullpay/target/release/nullpay.dll -Destination $WORKSPACE/cli\""

                    dir('cli') {
                        bat "PowerShell.exe \"&{(Get-Content -Path docker_pool_transactions_genesis -Raw) -replace '10\\.0\\.0\\.2','$INDY_SDK_SERVER_IP'} | Set-Content -Path docker_pool_transactions_genesis\""

                        def featuresArgs = ''
//                      def featuresArgs = '--features "nullpay_plugin"' // disabled because of IS-1109

                        echo "Windows Indy Cli Test: Build"
                        withEnv([
                                "RUST_BACKTRACE=1"
                        ]) {
                            bat "cargo build --release --features fatal_warnings"

                            echo "Windows Indy Cli Test: Build tests"
                            bat "cargo test --release $featuresArgs --no-run"

                            echo "Windows Indy Cli Test: Run tests"
                            withEnv([
                                    "RUST_TEST_THREADS=1",
                                    "RUST_LOG=indy::=debug,zmq=trace",
                                    "TEST_POOL_IP=$INDY_SDK_SERVER_IP"
                            ]) {
                                bat "cargo test --release $featuresArgs"
                            }
                        }

                        stash includes: 'target/release/indy-cli.exe,target/release/*.dll', name: 'IndyCliWindowsBuildResult'
                    }

                    bat "PowerShell.exe \"Copy-Item $WORKSPACE/libnullpay/target/release/nullpay.dll -Destination $WORKSPACE/vcx/libvcx\""

                    dir('vcx/libvcx') {
                        echo "Windows Libvcx Test: Build"

                        // FIXME remove that once https://jira.hyperledger.org/browse/IS-1127 is resolved
                        bat """
                            PowerShell.exe "&{(Get-Content -Path src/settings.rs -Raw) -replace '/tmp/test_init.json','./test_init.json'} | Set-Content -Path src/settings.rs"
                        """

                        withEnv([
                                "OPENSSL_DIR=$WORKSPACE\\libindy\\prebuilt",
                                "RUST_BACKTRACE=1"
                        ]) {
                            bat "cargo build --release --features fatal_warnings"
                            bat "cargo test --release --no-run"

                            echo "Windows Libvcx Test: Run tests"
                            withEnv([
                                    "RUST_TEST_THREADS=1",
                                    "RUST_LOG=vcx=debug,indy::=debug",
                                    "PATH=$WORKSPACE\\libindy\\target\\release;$PATH",
                            ]) {
                                bat "cargo test --release"
                            }
                        }

                        stash includes: 'target/release/*.dll,target/release/*.dll.lib', name: 'LibvcxWindowsBuildResult'
                    }
                } finally {
                    try {
                        bat "docker -H $INDY_SDK_SERVER_IP stop indy_pool"
                    } catch (ignore) {
                    }
                    try {
                        bat "docker -H $INDY_SDK_SERVER_IP rm indy_pool"
                    } catch (ignore) {
                    }
                    cleanWs()
                }
            }
            cleanWs()
        }
    }
}

def ubuntuTesting() {
    stage('Ubuntu Test') {
        linuxTesting("ci/ubuntu.dockerfile ci", "Ubuntu", "pool_network", true)
    }
}

def linuxAndroidOnEmulatorTesting(env_name, network_name, testEnv, stashBuildResult) {
    sh 'chmod -R 777 libindy/ci/*.sh'
    sh 'chmod -R 777 libindy/*.sh'

    def emu_arch = "x86"

    echo "${env_name} Libindy Test: Test on ${emu_arch} emulator"
    testEnv.inside("--network=${network_name}") {
        sh "cd libindy && ./android.test.sh ${emu_arch} --release"
    }
}

def iosTesting() {

    def setupRustIOS = {
        sh "rustup target add aarch64-apple-ios armv7-apple-ios armv7s-apple-ios i386-apple-ios x86_64-apple-ios"
    }

    def cleanSimulators = {
        sh '''
            xcrun simctl list devices | grep 'IndySDK' | awk '{print $4}' | sed -n  's/(\\(.*\\))/\\1/p'
            xcrun simctl list devices | grep 'IndySDK' | awk '{print $4}' | sed -n  's/(\\(.*\\))/\\1/p' | xargs xcrun simctl delete
        '''
    }

    def createSimulators = {
        sh '''
            xcrun simctl create "iPhone X IndySDK" "iPhone X" "11.2"
        '''
    }

    node('macos') {
        stage('iOS Test') {
            try {
                echo "iOS Test: Checkout scm"
                checkout scm

                echo "iOS Test: setup rust, brew and simulators"
                setupRust()
                setupRustIOS()
                setupBrewPackages()
                cleanSimulators()
                createSimulators()

                withEnv([
                        "BUNDLE_PATH=$HOME/.gem.indy_sdk"
                ]) {
                    dir('wrappers/ios') {
                        echo "iOS Test: Installing ruby, bundler and gems"

                        sh '''
                            rbenv install -s $(cat .ruby-version)

                            gem install bundler
                            bundler exec gem env

                            bundler install
                            bundler list
                        '''
                    }

                    dir('wrappers/ios/libindy-pod') {
                        echo "iOS Test: Installing dependencies (pods)"
                        sh "bundler exec pod install --repo-update"
                    }

                    echo "iOS Test: Building Libindy Universal iOS Pod"
                    buildIOSPod("libindy", "")

                    echo "iOS Test: Running pool"
                    sh "docker rm -f indy_pool || true"
                    sh "docker build -f ci/indy-pool.dockerfile -t indy_pool ci"
                    sh "docker run -d --name indy_pool -p 9701-9708:9701-9708 indy_pool"

                    // FIXME replace this hack (manually rewrite installed pod)
                    sh "rm -f wrappers/ios/libindy-pod/Pods/libindy/*.[ah]"
                    sh "cp libindy/out_pod/*.[ah] wrappers/ios/libindy-pod/Pods/libindy"

                    dir('wrappers/ios/libindy-pod') {
                        echo "iOS Test: Testing"
                        sh "xcodebuild test -workspace Indy.xcworkspace -scheme Indy-demo -destination 'platform=iOS Simulator,name=iPhone X IndySDK,OS=11.2'"
                    }

                    stash includes: 'libindy/out_pod/libindy.tar.gz', name: "LibindyUniversalIOSPod"

                    echo "iOS Test: Building Libindy iOS Pod for aarch64-apple-ios and armv7-apple-ios"
                    buildIOSPod("libindy", "aarch64-apple-ios armv7-apple-ios")
                    stash includes: 'libindy/out_pod/libindy.tar.gz', name: "LibindyMiniIOSPod"

                    echo "iOS Test: Building Libnullpay Universal iOS Pod"
                    buildIOSPod("libnullpay", "")
                    stash includes: 'libnullpay/out_pod/libnullpay.tar.gz', name: "LibnullpayUniversalIOSPod"

                    echo "iOS Test: Building Libnullpay iOS Pod for aarch64-apple-ios and armv7-apple-ios"
                    buildIOSPod("libnullpay", "aarch64-apple-ios armv7-apple-ios")
                    stash includes: 'libnullpay/out_pod/libnullpay.tar.gz', name: "LibnullpayMiniIOSPod"
                }

            } finally {
                try {
                    cleanSimulators()
                } catch (ignore) {
                }
                try {
                    sh "docker stop indy_pool"
                } catch (ignore) {
                }
                try {
                    sh "docker rm indy_pool"
                } catch (ignore) {
                }
                step([$class: 'WsCleanup'])
            }
        }
    }
}

def buildIOSPod(packageName, targets) {
    sh 'chmod -R 777 ci'
    sh "rm -rf ${packageName}/out_pod"
    echo "iOS Test: build ${packageName} pod"
    sh "ci/ios-build.sh $packageName $targets"
}

def rhelTesting() {
    stage('RedHat Test') {
        linuxTesting("ci/amazon.dockerfile ci", "RedHat", "pool_network", false)
    }
}

def macosTesting() {
    node('macos') {
        stage('MacOS Test') {
            try {
                echo "MacOS Test: Checkout scm"
                checkout scm

                setupRust()
                setupBrewPackages()

                macosModuleBuilding('libindy') // TODO: testing

                stash includes: 'libindy/target/release/libindy.dylib,libindy/target/release/libindy.a', name: 'LibindyMacosBuildResult'

                sh "cp libindy/target/release/libindy.dylib libnullpay"
                sh "cp libindy/target/release/libindy.dylib vcx/libvcx"

                macosModuleBuilding('libnullpay') // TODO: testing

                stash includes: 'libnullpay/target/release/libnullpay.dylib,libnullpay/target/release/libnullpay.a', name: 'LibnullpayMacosBuildResult'

                sh "cp libnullpay/target/release/libnullpay.dylib vcx/libvcx"

                macosModuleBuilding('vcx/libvcx')

                stash includes: 'vcx/libvcx/target/release/libvcx.dylib,vcx/libvcx/target/release/libvcx.a', name: 'LibvcxMacosBuildResult'

                macosModuleTesting('vcx/libvcx')

                //TODO wrappers testing
            } finally {
                step([$class: 'WsCleanup'])
            }
        }
    }
}

def macosModuleBuilding(library) {
    dir(library) {
        echo "MacOS ${library} Testing: Build"
        sh "LIBRARY_PATH=./ cargo build --release --features fatal_warnings"
        sh "LIBRARY_PATH=./ cargo test --release --no-run"
    }
}

def macosModuleTesting(library) {
    dir(library) {
        echo "MacOS ${library} Testing: Run Tests"
        sh "LIBRARY_PATH=./ RUST_TEST_THREADS=1 cargo test --release"
    }
}

def rhelPublishing() {
    def libindyVersion;

    node('ubuntu') {
        stage('Publish Libindy RPM Files') {
            try {
                echo 'Publish Rpm files: Checkout csm'
                checkout scm

                libindyVersion = getSrcVersion("libindy")

                dir('libindy') {
                    echo 'Publish Rpm: Build docker image'
                    def testEnv = dockerHelpers.build('indy-sdk', 'ci/amazon.dockerfile ci')

                    testEnv.inside('-u 0:0') {

                        sh 'chmod -R 777 ci'

                        withCredentials([file(credentialsId: 'EvernymRepoSSHKey', variable: 'repo_key')]) {
                            sh "./ci/libindy-rpm-build-and-upload.sh $version $repo_key $env.BRANCH_NAME $env.BUILD_NUMBER"
                        }
                    }
                }
            }
            finally {
                echo 'Publish RPM: Cleanup'
                step([$class: 'WsCleanup'])
            }
        }
    }
    return libindyVersion
}

def ubuntuPublishing() {
    def libindyVersion

    node('ubuntu') {
        stage('Publish Ubuntu Files') {
            try {
                echo 'Publish Ubuntu files: Checkout scm'
                checkout scm

                libindyVersion = getSrcVersion("libindy")

                echo 'Publish Ubuntu files: Build docker image'
                testEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')

                libindyDebPublishing(testEnv, libindyVersion)

                pythonWrapperPublishing(testEnv, false, 'wrappers/python', 'libindy')
                nodejsWrapperPublishing(testEnv, false, 'libindy')
                javaWrapperPublishing(testEnv, false)
                rustWrapperPublishing(testEnv, false)
                libindyCliDebPublishing(testEnv, libindyVersion)
                libnullpayDebPublishing(testEnv)
                libvcxDebPublishing(testEnv)
                vcxJavaWrapperPublishing(testEnv, false)
                pythonWrapperPublishing(testEnv, false, 'vcx/wrappers/python3', 'vcx/libvcx')
                nodejsWrapperPublishing(testEnv, false, 'vcx')
            }
            finally {
                echo 'Publish Ubuntu files: Cleanup'
                step([$class: 'WsCleanup'])
            }
        }
    }
    return libindyVersion
}

def rustWrapperPublishing(testEnv, isRelease) {

    def ver = getSrcVersion("wrappers/rust")
    def suffix = getSuffix(isRelease, "Cargo")

    echo 'Publish Indy-Sys to Cargo'

    dir('wrappers/rust/indy-sys') {
        publishToCargo(testEnv, suffix, ver)
    }

    echo 'Publish Indy to Cargo'

    dir('wrappers/rust') {
        if (testReleaseVersion) {
            sh "sed -i -E -- 's/indy-sys = \\{ path =\"indy-sys\", version = \"=([0-9,.]+)\" \\}/indy-sys = \\{ path =\"indy-sys\", version = \"=${testReleaseVersion}${suffix}\" \\}/g' Cargo.toml"
        } else {
            sh "sed -i -- 's/indy-sys = { path =\"indy-sys\", version = \"=$ver\" }/indy-sys = { path =\"indy-sys\", version = \"=$ver$suffix\" }/g' Cargo.toml"
        }
        publishToCargo(testEnv, suffix, ver)
    }
}

def publishToCargo(testEnv, suffix, ver) {
    testEnv.inside {
        if (testReleaseVersion) {
            sh "sed -i -E -e 'H;1h;\$!d;x' -e \"s/version = \\\"([0-9,.]+)/version = \\\"${testReleaseVersion}${suffix}/\" Cargo.toml"
        } else {
            sh "sed -i -E -e 'H;1h;\$!d;x' -e \"s/version = \\\"$ver/version = \\\"$ver$suffix/\" Cargo.toml"
        }

        withCredentials([string(credentialsId: 'cargoSecretKey', variable: 'LOGIN')]) {
            sh 'cargo login $LOGIN'
            sh 'cargo package --allow-dirty'
            sh 'cargo publish --allow-dirty'
        }
    }
}

def windowsPublishing() {
    def libindyVersion
    node('ubuntu') {
        stage('Publish Libindy Windows Files') {
            try {
                echo 'Publish Windows files: Checkout scm'
                checkout scm

                libindyVersion = getSrcVersion("libindy")

                echo 'Publish Windows files: Build docker image'
                testEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')

                echo 'Publish Libindy Windows files'
                windowsPublishArtifact(testEnv, "libindy", "libindy", "lib", libindyVersion, "LibindyWindowsBuildResult")

                echo 'Publish Indy Cli Windows files'
                windowsPublishArtifact(testEnv, "cli", "indy-cli", "executable", libindyVersion, "IndyCliWindowsBuildResult")

                echo 'Publish Libnullpay Windows files'
                def libnullpayVersion = getSrcVersion("libnullpay")
                windowsPublishArtifact(testEnv, "libnullpay", "libnullpay", "lib", libnullpayVersion, "LibnullpayWindowsBuildResult")

                echo 'Publish Libvcx Windows files'
                def libvcxVersion = getSrcVersion("vcx/libvcx")
                windowsPublishArtifact(testEnv, "vcx/libvcx", "libvcx", "lib", libvcxVersion, "LibvcxWindowsBuildResult")

            }
            finally {
                echo 'Publish Windows files: Cleanup'
                step([$class: 'WsCleanup'])
            }
        }
    }
    return libindyVersion
}

def windowsPublishArtifact(testEnv, folder, packageName, packageType, packageVersion, stashName) {
    testEnv.inside {
        sh 'chmod -R 777 ci'

        unstash name: stashName

        withCredentials([file(credentialsId: 'SovrinRepoSSHKey', variable: 'repo_key')]) {
            withEnv([
                    "SOVRIN_REPO_HOST=$SOVRIN_REPO_HOST",
            ]) {
                sh "ci/win-zip-and-upload.sh $folder $packageName $packageType $packageVersion '${repo_key}' $env.BRANCH_NAME $env.BUILD_NUMBER"
            }
        }
    }
}

def iosPublishing() {
    def libindyVersion
    node('ubuntu') {
        stage('Publish Libindy iOS Files') {
            try {
                echo 'Publish iOS files: Checkout scm'
                checkout scm

                libindyVersion = getSrcVersion("libindy")
                version = "$libindyVersion-$env.BUILD_NUMBER"

                echo 'Publish iOS files: Build docker image'
                testEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')

                echo 'Publish Libindy iOS Pod for aarch64-apple-ios and armv7-apple-ios'
                publishIOSAtrifacts(testEnv, "libindy", "LibindyMiniIOSPod", version, "libindy-aarch64-armv7.tar.gz")

                echo 'Publish Libindy iOS Universal Pod'
                publishIOSAtrifacts(testEnv, "libindy", "LibindyUniversalIOSPod", version, null)

                echo 'Publish Libnullpay iOS Pod for aarch64-apple-ios and armv7-apple-ios'
                publishIOSAtrifacts(testEnv, "libnullpay", "LibnullpayMiniIOSPod", version, "libnullpay-aarch64-armv7.tar.gz")

                echo 'Publish Libnullpay iOS Universal Pod'
                publishIOSAtrifacts(testEnv, "libnullpay", "LibnullpayUniversalIOSPod", version, null)
            }
            finally {
                echo 'Publish iOS files: Cleanup'
                step([$class: 'WsCleanup'])
            }
        }
    }
    return libindyVersion
}

def publishIOSAtrifacts(testEnv, packageName, stashName, version, targetName) {
    testEnv.inside {
        unstash name: stashName

        withCredentials([file(credentialsId: 'SovrinRepoSSHKey', variable: 'sovrin_repo_key')]) {
            target = "/var/repository/repos/ios/$packageName/$env.BRANCH_NAME/$packageName-core"

            sh "ssh -v -oStrictHostKeyChecking=no -i '$sovrin_repo_key' repo@$SOVRIN_REPO_HOST mkdir -p $target/$version"
            sh "scp -r -oStrictHostKeyChecking=no -i $sovrin_repo_key $packageName/out_pod/${packageName}.tar.gz repo@$SOVRIN_REPO_HOST:$target/$version/"

            if (targetName != null) {
                sh "ssh -v -oStrictHostKeyChecking=no -i $sovrin_repo_key repo@$SOVRIN_REPO_HOST mv $target/$version/${packageName}.tar.gz $target/$version/$targetName"
            }
        }
    }
}

def macOsPublishing() {
    node('ubuntu') {
        stage('Publish Libindy MacOS Files') {
            try {
                echo 'Publish iOS files: Checkout scm'
                checkout scm

                echo 'Publish MacOS files: Build docker image'
                def libindyVersion = getSrcVersion("libindy")
                testEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')

                echo 'Publish Libindy MacOS Library'
                publishMacOsArtifact(testEnv, "libindy", "libindy", "LibindyMacosBuildResult", libindyVersion)

                echo 'Publish Libnullpay MacOS Library'
                def libnullpayVersion = getSrcVersion("libnullpay")
                publishMacOsArtifact(testEnv, "libnullpay", "libnullpay", "LibnullpayMacosBuildResult", libnullpayVersion)

                echo 'Publish Libvcx MacOS Library'
                def libvcxVersion = getSrcVersion("vcx/libvcx")
                publishMacOsArtifact(testEnv, "libvcx", "vcx/libvcx", "LibvcxMacosBuildResult", libvcxVersion)
            }
            finally {
                echo 'Publish iOS files: Cleanup'
                step([$class: 'WsCleanup'])
            }
        }
    }
}

def publishMacOsArtifact(testEnv, packageName, packagePath, stashName, packageVersion) {
    testEnv.inside {
        sh 'chmod -R 777 ci'

        unstash name: stashName

        withCredentials([file(credentialsId: 'SovrinRepoSSHKey', variable: 'repo_key')]) {
            withEnv([
                    "SOVRIN_REPO_HOST=$SOVRIN_REPO_HOST",
            ]) {
                sh "ci/macos-zip-and-upload.sh $packagePath $packageName $packageVersion '${repo_key}' $env.BRANCH_NAME $env.BUILD_NUMBER"
            }
        }
    }
}

def getSuffix(isRelease, target) {
    def suffix
    if (env.BRANCH_NAME == 'master' && !isRelease) {
        suffix = "-dev-$env.BUILD_NUMBER"
    } else if (env.BRANCH_NAME == 'rc') {
        if (isRelease) {
            suffix = ""
        } else {
            suffix = "-rc-$env.BUILD_NUMBER"
        }
    } else {
        error "Publish To ${target}: invalid case: branch ${env.BRANCH_NAME}, isRelease ${isRelease}"
    }
    return suffix
}

def libindyDebPublishing(testEnv, version) {
    echo 'Publish Libindy deb files to Apt'

    debPublishing(testEnv, "libindy", "libindy", version, "LibindyUbuntuBuildResult", "libindyDebs")
}

def libindyCliDebPublishing(testEnv, version) {
    echo 'Publish Indy Cli deb files to Apt'

    setLibindyDependencyVersion("cli/debian/control")

    debPublishing(testEnv, "cli", "indy-cli", version, "IndyCliUbuntuBuildResult", "libindyCliDebs")
}

def libnullpayDebPublishing(testEnv) {
    echo 'Publish Libnullpay deb files to Apt'

    def libnullpayVersion = getSrcVersion("libnullpay")

    setLibindyDependencyVersion("libnullpay/debian/control")

    debPublishing(testEnv, "libnullpay", "libnullpay", libnullpayVersion, "LibnullpayUbuntuBuildResult", "libnullpayDebs")
}

def libvcxDebPublishing(testEnv) {
    echo 'Publish Libvcx deb files to Apt'

    def libvcxVersion = getSrcVersion("vcx/libvcx")

    setLibindyDependencyVersion("vcx/libvcx/debian/control")

    debPublishing(testEnv, "vcx/libvcx", "libvcx", libvcxVersion, "LibvcxUbuntuBuildResult", "libvcxDebs")
}

def setLibindyDependencyVersion(file) {
    def libindyVersion = getSrcVersion("libindy")
    def replaceVersion = "$libindyVersion~$env.BUILD_NUMBER"

    sh "sed -i -e \"s/^\\(Depends: .*libindy\\)\\(\\s*[,]\\{,1\\}.*\\)/\\1 (= $replaceVersion)\\2/\" $file"
}

def debPublishing(testEnv, directory, packageName, version, inStashName, outStashName) {
    dir("$directory/sovrin-packaging") {
        downloadPackagingUtils()
    }

    testEnv.inside {
        sh "cp ci/deb-build-and-upload.sh $directory && chmod -R 755 $directory/*.sh"

        def suffix = "~$env.BUILD_NUMBER"

        unstash name: inStashName

        withCredentials([file(credentialsId: 'SovrinRepoSSHKey', variable: 'sovrin_key')]) {
            sh "cd $directory && ./deb-build-and-upload.sh $packageName $version $env.BRANCH_NAME $suffix $SOVRIN_SDK_REPO_NAME $SOVRIN_REPO_HOST $sovrin_key"

            if (env.BRANCH_NAME == 'rc') {
                stash includes: "$directory/debs/*", name: outStashName
            }
        }
    }
}

def pythonWrapperPublishing(testEnv, isRelease, directory, base_library) {
    def version = getSrcVersion(base_library)

    dir(directory) {
        def suffix = getSuffix(isRelease, "Pypi")

        testEnv.inside {
            withCredentials([file(credentialsId: 'pypi_credentials', variable: 'credentialsFile')]) {
                sh 'cp $credentialsFile ./'

                sh "PACKAGE_VERSION=$version$suffix python3.5 setup.py sdist"
                sh "python3.5 -m twine upload dist/* --config-file .pypirc"

            }
        }
    }
}

def nodejsWrapperPublishing(testEnv, isRelease, library) {
    def paths = ['libindy': ['dir': 'wrappers/nodejs', 'base_library': 'libindy'],
                 'vcx'    : ['dir': 'vcx/wrappers/node', 'base_library': 'vcx/libvcx']]

    def version = getSrcVersion(paths[library]['base_library'])

    def suffix = getSuffix(isRelease, "nodejs")

    def directory = paths[library]['dir']

    testEnv.inside {
        if (library == 'vcx') { // need addition step for VCX to create .js files
            sh "cd $directory && npm i && npm run compile"
        }

        npmPublish(version, suffix, directory)
    }
}

def npmPublish(version, suffix, directory) {
    withCredentials([file(credentialsId: 'npm_credentials', variable: 'credentialsFile')]) {
        sh 'cp $credentialsFile ~/.npmrc'
        sh "cd $directory && " +
                "npm version --no-git-tag-version --allow-same-version $version$suffix &&" +
                "npm publish"
    }
}

def javaWrapperPublishing(testEnv, isRelease) {
    dir('wrappers/java') {
        echo "Publish To Maven Test: Build docker image"
        def suffix = getSuffix(isRelease, "Maven")

        testEnv.inside {
            echo "Publish To Maven Test: Test"

            if (testReleaseVersion) {
                sh "sed -i -E -e 'H;1h;\$!d;x' -e \"s/<version>([0-9,.]+)</<version>${testReleaseVersion}${suffix}</\" pom.xml"
            } else {
                sh "sed -i -E -e 'H;1h;\$!d;x' -e \"s/<version>([0-9,.]+)</<version>\\1$suffix</\" pom.xml"
            }

            withCredentials([file(credentialsId: 'maven-settings', variable: 'settingsFile')]) {
                sh 'cp $settingsFile .'

                sh "mvn clean deploy -DskipTests $mavenDeployAddOptions --settings settings.xml"
            }
        }
    }
}

def vcxJavaWrapperPublishing(testEnv, isRelease) {
    dir('vcx/wrappers/java') {
        echo "Publish To Maven Test: Build docker image"
        def version = getSrcVersion("vcx/libvcx")
        def suffix = getSuffix(isRelease, "Maven")

        testEnv.inside {
            echo "Publish To Maven Test: Test"
            withCredentials([file(credentialsId: 'maven-settings', variable: 'settingsFile')]) {
                sh 'cp $settingsFile .'

                sh "ci/buildJar.sh ${version}${suffix}"

                sh "chmod +x ci/publishJar.sh"

                withEnv([
                        "MAVEN_ADD_OPTIONS=$mavenDeployAddOptions",
                ]) {
                    sh 'ci/publishJar.sh'
                }
            }
        }
    }
}

def publishingRCtoStable() {
    node('ubuntu') {
        stage('Moving RC artifacts to Stable') {
            try {
                echo 'Moving RC artifacts to Stable: Checkout scm'
                checkout scm

                echo 'Moving RC artifacts to Stable: Download packaging utils'
                dir('sovrin-packaging') {
                    downloadPackagingUtils()
                }

                def libindyVersion = getSrcVersion("libindy")
                def libnullpayVersion = getSrcVersion("libnullpay")
                def libvcxVersion = getSrcVersion("vcx/libvcx")

                echo 'Moving Windows RC artifacts to Stable: libindy'
                publishLibindyWindowsFilesRCtoStable(libindyVersion)

                echo 'Moving RC artifacts to Stable: Build docker image for wrappers publishing'
                testEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')

                echo 'Moving Ubuntu RC artifacts to Stable: libindy'
                publishLibindyDebRCtoStable(testEnv, libindyVersion)

                echo 'Moving Ubuntu RC artifacts to Stable: python wrapper'
                pythonWrapperPublishing(testEnv, true, 'wrappers/python', 'libindy')

                echo 'Moving Ubuntu RC artifacts to Stable: nodejs wrapper'
                nodejsWrapperPublishing(testEnv, true, 'libindy')

                echo 'Moving Ubuntu RC artifacts to Stable: java wrapper'
                javaWrapperPublishing(testEnv, true)

                echo 'Moving Ubuntu RC artifacts to Stable: rust wrapper'
                rustWrapperPublishing(testEnv, true)

                echo 'Moving Ubuntu RC artifacts to Stable: indy-cli'
                publishLibindyCliDebRCtoStable(testEnv, libindyVersion)

                echo 'Moving Windows RC artifacts to Stable: indy-cli'
                publishLibindyCliWindowsFilesRCtoStable(libindyVersion)

                echo 'Moving Windows RC artifacts to Stable: libnullpay'
                publishLibnullpayWindowsFilesRCtoStable(libnullpayVersion)

                echo 'Moving Ubuntu RC artifacts to Stable: libnullpay'
                publishLibnullpayDebRCtoStable(testEnv)

                echo 'Moving Windows RC artifacts to Stable: libvcx'
                publishLibVCXWindowsFilesRCtoStable(libvcxVersion)

                echo 'Moving Ubuntu RC artifacts to Stable: libvcx'
                publishLibvcxDebRCtoStable(testEnv)

                echo 'Moving Ubuntu RC artifacts to Stable: vcx java wrapper'
                vcxJavaWrapperPublishing(testEnv, true)

                echo 'Moving Ubuntu RC artifacts to Stable: vcx python wrapper'
                pythonWrapperPublishing(testEnv, true, 'vcx/wrappers/python3', 'vcx/libvcx')

                echo 'Moving Ubuntu RC artifacts to Stable: vcx nodejs wrapper'
                nodejsWrapperPublishing(testEnv, true, 'vcx')

                echo 'Moving Android RC artifacts to Stable: libindy'
                publishLibindAndroidFilesRCtoStable(libindyVersion)

                echo 'Moving Android RC artifacts to Stable: libnullpay'
                publishLibnullpayAndroidFilesRCtoStable()

                echo 'Moving iOS RC artifacts to Stable: libindy'
                publishLibindyIOSFilesRCtoStable(libindyVersion)

                echo 'Moving iOS RC artifacts to Stable: libnullpay'
                publishLibnullpayIOSFilesRCtoStable(libnullpayVersion)

                echo 'Moving MacOS RC artifacts to Stable: libindy'
                publishLibindyMacOSFilesRCtoStable(libindyVersion)

                echo 'Moving MacOS RC artifacts to Stable: libnullpay'
                publishLibnullpayMacOSFilesRCtoStable(libnullpayVersion)

                echo 'Moving MacOS RC artifacts to Stable: libvcx'
                publishLibvcxMacOSFilesRCtoStable(libvcxVersion)
            } finally {
                echo 'Moving RC artifacts to Stable: Cleanup'
                step([$class: 'WsCleanup'])
            }
        }
    }
}

def publishLibindyWindowsFilesRCtoStable(version) {
    publishWindowsFilesRCtoStable("libindy", version)
}

def publishLibindyCliWindowsFilesRCtoStable(version) {
    publishWindowsFilesRCtoStable("indy-cli", version)
}

def publishLibnullpayWindowsFilesRCtoStable(libnullpayVersion) {
    publishWindowsFilesRCtoStable("libnullpay", libnullpayVersion)
}

def publishLibVCXWindowsFilesRCtoStable(libvcxVersion) {
    publishWindowsFilesRCtoStable("libvcx", libvcxVersion)
}

def publishLibindAndroidFilesRCtoStable(version) {
    publishAndroidFilesRCtoStable("libindy", version)
}

def publishLibnullpayAndroidFilesRCtoStable() {
    def libnullpayVersion = getSrcVersion("libnullpay")
    publishAndroidFilesRCtoStable("libnullpay", libnullpayVersion)
}

def publishAndroidFilesRCtoStable(packageName, version) {
    copyRcFilesToStable("android", packageName, version)
}

def publishWindowsFilesRCtoStable(packageName, version) {
    copyRcFilesToStable("windows", packageName, version)
}

def copyRcFilesToStable(platform, packageName, version) {
    rcFullVersion = fullVersion(version)

    src = "/var/repository/repos/$platform/$packageName/rc/$rcFullVersion/"
    target = "/var/repository/repos/$platform/$packageName/stable/$version"

    copyFilesFromRcToStable(src, target)
}

def publishLibindyIOSFilesRCtoStable(version) {
    rcFullVersion = fullVersion(version)

    src = "/var/repository/repos/ios/libindy/rc/libindy-core/$rcFullVersion/"
    target = "/var/repository/repos/ios/libindy/stable/libindy-core/$version/"

    copyFilesFromRcToStable(src, target)
}

def publishLibnullpayIOSFilesRCtoStable(version) {
    rcFullVersion = fullVersion(version)

    src = "/var/repository/repos/ios/libnullpay/rc/libnullpay-core/$rcFullVersion/"
    target = "/var/repository/repos/ios/libnullpay/stable/libnullpay-core/$version/"

    copyFilesFromRcToStable(src, target)
}

def publishLibindyMacOSFilesRCtoStable(version) {
    rcFullVersion = fullVersion(version)

    src = "/var/repository/repos/macos/libindy/rc/$rcFullVersion/"
    target = "/var/repository/repos/macos/libindy/stable/$version/"

    copyFilesFromRcToStable(src, target)
}

def publishLibnullpayMacOSFilesRCtoStable(version) {
    rcFullVersion = fullVersion(version)

    src = "/var/repository/repos/macos/libnullpay/rc/$rcFullVersion/"
    target = "/var/repository/repos/macos/libnullpay/stable/$version/"

    copyFilesFromRcToStable(src, target)
}

def publishLibvcxMacOSFilesRCtoStable(version) {
    rcFullVersion = fullVersion(version)

    src = "/var/repository/repos/macos/libvcx/rc/$rcFullVersion/"
    target = "/var/repository/repos/macos/libvcx/stable/$version/"

    copyFilesFromRcToStable(src, target)
}

def fullVersion(version) {
    return "${version}-${env.BUILD_NUMBER}"
}

def copyFilesFromRcToStable(src, target) {
    withCredentials([file(credentialsId: 'SovrinRepoSSHKey', variable: 'sovrin_repo_key')]) {
        sh "ssh -v -oStrictHostKeyChecking=no -i '$sovrin_repo_key' repo@$SOVRIN_REPO_HOST '! ls $target'"
        sh "ssh -v -oStrictHostKeyChecking=no -i '$sovrin_repo_key' repo@$SOVRIN_REPO_HOST cp -r $src $target"
    }
}

def publishLibindyDebRCtoStable(testEnv, version) {
    publishDebRCtoStable(testEnv, "libindy", "libindy", version, "libindyDebs", true)
}

def publishLibindyCliDebRCtoStable(testEnv, version) {
    publishDebRCtoStable(testEnv, "indy-cli", "cli", version, "libindyCliDebs", false)
}

def publishLibnullpayDebRCtoStable(testEnv) {
    def libnullpayVersion = getSrcVersion("libnullpay")
    publishDebRCtoStable(testEnv, "libnullpay", "libnullpay", libnullpayVersion, "libnullpayDebs", false)
}

def publishLibvcxDebRCtoStable(testEnv) {
    def libvcxVersion = getSrcVersion("vcx/libvcx")

    publishDebRCtoStable(testEnv, "libvcx", "vcx/libvcx", libvcxVersion, "libvcxDebs", false)
}

def publishDebRCtoStable(testEnv, packageName, folder, version, stashName, moveDevArtifacts) {
    testEnv.inside {
        def rcFullVersion = "${version}~${env.BUILD_NUMBER}"

        unstash name: stashName

        if (packageName != "libindy") {
            def libindyVersion = getSrcVersion("libindy")
            sh "fpm -s deb -t deb --version $rcFullVersion --no-auto-depends --depends 'libindy = $libindyVersion' -f -p $folder/debs $folder/debs/\"$packageName\"_\"$rcFullVersion\"_amd64.deb"
        }

        sh "fakeroot deb-reversion -v $version $folder/debs/\"$packageName\"_\"$rcFullVersion\"_amd64.deb"

        if (moveDevArtifacts) {
            sh "fakeroot deb-reversion -v $version $folder/debs/\"$packageName\"-dev_\"$rcFullVersion\"_amd64.deb"
        }

        withCredentials([file(credentialsId: 'SovrinRepoSSHKey', variable: 'sovrin_key')]) {
            path = sh(returnStdout: true, script: 'pwd').trim()

            sh "./sovrin-packaging/upload_debs.py $path $SOVRIN_SDK_REPO_NAME stable --host $SOVRIN_REPO_HOST --ssh-key $sovrin_key"
        }
    }
}

def buildTestEnv(file, env_name) {
    dir('libindy') {
        echo "${env_name} Build test environment"
        return dockerBuild('libindy', file)
    }
}

def downloadPackagingUtils() {
    git branch: sovrinPackagingBranch, credentialsId: gitHubUserCredId, url: sovrinPackagingRepo
}

def shell(command) {
    if (isUnix()) {
        sh command
    } else {
        bat command
    }
}

def setupRust() {
    shell("rustup default 1.34.1")
}

def androidPublishing() {
    def libindyVersion
    def libnullpayVersion

    node('ubuntu') {
        stage('Publish Android binaries') {
            try {
                echo 'Publish Android files: Checkout scm'
                checkout scm

                libindyVersion = getSrcVersion("libindy")
                libnullpayVersion = getSrcVersion("libnullpay")

                echo 'Publish Android binaries: Building docker image'
                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
                publishAndroid(buildEnv, libindyVersion, libnullpayVersion)

            }
            finally {
                echo 'Publish Android binaries: Cleanup'
                step([$class: 'WsCleanup'])
            }
        }
    }
}

def buildAndroid(buildEnv, libIndyVersion, libnullpayVersion) {

    for (arch in ["arm", "armv7", "x86", "arm64", "x86_64"]) {
        androidBuildArtifact(buildEnv, arch, libIndyVersion, 'libindy')
        androidBuildArtifact(buildEnv, arch, libnullpayVersion, 'libnullpay')
    }
}

def publishAndroid(buildEnv, libIndyVersion, libnullpayVersion) {

    for (arch in ["arm", "armv7", "x86", "arm64", "x86_64"]) {
        androidPublishArtifact(buildEnv, arch, libIndyVersion, 'libindy')
        androidPublishArtifact(buildEnv, arch, libnullpayVersion, 'libnullpay')
    }
}

def androidBuildArtifact(buildEnv, arch, libVersion, artifact) {

    def ANDROID_SCRIPT_PATH = 'android.build.sh'
    echo "Building $artifact android files for $arch"
    def artifactName = artifact.toString().toUpperCase()

    if (artifactName == "LIBINDY") {
        buildEnv.inside {
            sh "cd libindy && ${artifactName}_VERSION=${libVersion} ./${ANDROID_SCRIPT_PATH} -d $arch"
            def libindy_zip_name = "libindy_android_${arch}_${libVersion}.zip"
            sh "cp libindy/${libindy_zip_name} ./"
            stash includes: "${libindy_zip_name}", name: "libindy_${arch}_zip"
        }
    } else if (artifactName == "LIBNULLPAY") {
        buildEnv.inside {
            unstash name: "libindy_${arch}_zip"
            sh "cp libindy_android_${arch}_${libVersion}.zip libnullpay && unzip -o libnullpay/libindy_android_${arch}_${libVersion}.zip "
            stash includes: "libindy_android_${arch}_${libVersion}.zip", name: "libindy_${arch}_zip"
            sh "${artifactName}_VERSION=${libVersion} INDY_DIR=../libindy_${arch}/lib ./libnullpay/${ANDROID_SCRIPT_PATH} -d $arch"
            def libnullpay_zip_name = "libnullpay_android_${arch}_${libVersion}.zip"
            sh "cp libnullpay/${libnullpay_zip_name} ./"
            stash includes: "${libnullpay_zip_name}", name: "libnullpay_${arch}_zip"
        }
    }
}

def androidPublishArtifact(buildEnv, arch, packageVersion, artifact) {
    buildEnv.inside {
        sh 'chmod -R 777 ci'

        echo "Publish ${artifact} android files for ${arch}"
        unstash name: "${artifact}_${arch}_zip"

        withCredentials([file(credentialsId: 'SovrinRepoSSHKey', variable: 'repo_key')]) {
            withEnv([
                    "SOVRIN_REPO_HOST=$SOVRIN_REPO_HOST",
            ]) {
                sh "ci/android-zip-and-upload.sh $arch $packageVersion '${repo_key}' $env.BRANCH_NAME $env.BUILD_NUMBER $artifact"
            }
        }
    }
}

def linuxModuleTesting(file, env_name, network_name, module_tester, stashBuildResults) {
    linuxModuleTesting(file, env_name, network_name, module_tester, stashBuildResults, 'ubuntu')
}

def linuxModuleTesting(file, env_name, network_name, module_tester, stashBuildResults, node_label) {
    node(node_label) {
        def poolInst
        try {
            echo "${env_name} Test: Checkout csm"
            checkout scm

            poolInst = openPool(env_name, network_name)

            def testEnv = buildTestEnv(file, env_name)

            module_tester(env_name, network_name, testEnv, stashBuildResults)
        } finally {
            closePool(env_name, network_name, poolInst)
        }
    }
}

def androidTesting() {
    env_name = "android_on_linux"
    network_name = "pool_network"
    parallel([
            "${env_name}-android-test"    : {
                linuxModuleTesting("ci/ubuntu.dockerfile ci", env_name, network_name, this.&linuxAndroidOnEmulatorTesting, false, 'android')
            },
            "${env_name}-android-building": { androidBuildAsTesting() }
    ])
}

def androidBuildAsTesting() {
    def libindyVersion

    node('ubuntu') {
        stage('Android test') {
            try {
                echo 'Building android binaries. This will act as a minimal test for android'
                checkout scm

                libindyVersion = getSrcVersion("libindy")
                def libnullpayVersion = getSrcVersion("libnullpay")
                echo 'Building android binaries: Building docker image'
                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
                sh 'chmod -R 777 libindy/'
                sh 'chmod -R 777 libindy/ci/'

                buildAndroid(buildEnv, libindyVersion, libnullpayVersion)
            }
            finally {
                echo 'Building Android binaries: Cleanup'
                step([$class: 'WsCleanup'])
            }
        }
    }
}

def setupBrewPackages() {
    sh "brew switch libsodium 1.0.12"
    sh "brew switch openssl 1.0.2q"
    sh "brew switch zeromq 4.2.3"
}
